import { NanoBananaGenerationRequest, NanoBananaResponse } from '@/types';
import { withCache } from './ai-cache';

/**
 * Nano Banana (Gemini 2.5 Flash Image) Service
 * Uses the direct Gemini API for image generation and editing
 * Based on: https://ai.google.dev/gemini-api/docs/image-generation
 */
class NanaBananaService {
  private apiKey: string;
  private model: string = 'gemini-2.5-flash-image-preview';
  private apiUrl: string = 'https://generativelanguage.googleapis.com/v1beta/models';

  constructor() {
    this.apiKey = process.env.GEMINI_API_KEY || '';
    if (!this.apiKey) {
      console.warn('GEMINI_API_KEY not configured. Nano Banana will not work.');
    }
  }

  /**
   * Generate images using text-to-image (Nano Banana)
   */
  async generateImage(request: NanoBananaGenerationRequest): Promise<NanoBananaResponse> {
    return withCache.image(request.prompt, request, async () => {
      try {
        console.log('üçå [Nano Banana] Starting image generation...');
        console.log('üìù Request:', JSON.stringify(request, null, 2));

        if (!this.apiKey) {
          throw new Error('GEMINI_API_KEY is not configured');
        }

      // Prepare the content array
      const contents = [{
        parts: [{
          text: request.prompt
        }]
      }];

      // Add input images if this is an editing request
      if (request.inputImages && request.inputImages.length > 0) {
        request.inputImages.forEach((imageData, index) => {
          contents[0].parts.push({
            inlineData: {
              mimeType: 'image/png', // Assuming PNG, could be dynamic
              data: imageData
            }
          } as any);
        });
      }

      const response = await fetch(
        `${this.apiUrl}/${this.model}:generateContent?key=${this.apiKey}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents
          }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Nano Banana API error: ${response.statusText} - ${JSON.stringify(errorData)}`);
      }

      const data = await response.json();
      console.log('üìû [Nano Banana] Raw response received');

      // Extract images from response
      const images: { id: string; data: string; mimeType: string; }[] = [];
      
      if (data.candidates && data.candidates[0]?.content?.parts) {
        for (const part of data.candidates[0].content.parts) {
          if (part.inlineData) {
            images.push({
              id: `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              data: part.inlineData.data,
              mimeType: part.inlineData.mimeType || 'image/png'
            });
          }
        }
      }

      if (images.length === 0) {
        console.log('‚ö†Ô∏è [Nano Banana] No images found in response. This might be due to:');
        console.log('   - Gemini 2.5 Flash Image not yet available in your region');
        console.log('   - API key lacks image generation permissions');  
        console.log('   - Model response format has changed');
        console.log('   - Using development mode without proper API setup');
        
        // For development/testing, create a placeholder response
        if (process.env.NODE_ENV === 'development') {
          console.log('üß™ [Nano Banana] Creating placeholder for development');
          images.push({
            id: `placeholder_${Date.now()}`,
            data: 'PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzY2NzA4NSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkdlbmVyYXRlZCBJbWFnZSBQbGFjZWhvbGRlcjwvdGV4dD48L3N2Zz4=',
            mimeType: 'image/svg+xml'
          });
        } else {
          throw new Error('No images were generated by Nano Banana - check API configuration');
        }
      }

      console.log(`‚úÖ [Nano Banana] Successfully generated ${images.length} image(s)`);
      
      return {
        success: true,
        images
      };

    } catch (error) {
      console.error('‚ùå [Nano Banana] Generation error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      };
    }
    });
  }

  /**
   * Edit existing images with text prompts (image + text-to-image)
   */
  async editImage(
    prompt: string, 
    inputImages: string[]
  ): Promise<NanoBananaResponse> {
    return this.generateImage({
      prompt,
      editMode: 'image-and-text-to-image',
      inputImages
    });
  }

  /**
   * Compose new images from multiple input images
   */
  async composeImages(
    prompt: string, 
    inputImages: string[]
  ): Promise<NanoBananaResponse> {
    return this.generateImage({
      prompt,
      editMode: 'multi-image-composition',  
      inputImages
    });
  }

  /**
   * Replace characters in images using reference photos
   * 
   * This is the core character replacement method that enables consistent
   * character representation across advertisement scenes. It uses Gemini 2.5 Flash Image
   * with multi-image composition to seamlessly integrate a reference character
   * into an existing scene while preserving the original image's aesthetics.
   * 
   * @param originalImageData - Base64 encoded image data of the scene to modify
   * @param characterImageData - Base64 encoded reference photo of the character to insert
   * @param prompt - Natural language description of the replacement task
   * @param options - Configuration options for the replacement
   * @param options.targetDescription - Specific description of what/who to replace in the original image
   * @param options.preserveStyle - Whether to maintain original image's lighting, composition, and style (default: true)
   * @param options.characterDescription - Additional context about the reference character
   * 
   * @returns Promise<NanoBananaResponse> - Contains success status and replacement image data
   * 
   * @example
   * ```typescript
   * const result = await nanoBanana.replaceCharacter(
   *   originalSceneBase64,
   *   ceoPhotoBase64,
   *   "Replace the person in this advertisement with our CEO",
   *   {
   *     targetDescription: "the person in the business suit",
   *     preserveStyle: true,
   *     characterDescription: "Professional CEO in formal business attire"
   *   }
   * );
   * ```
   * 
   * Technical Implementation:
   * - Uses Gemini 2.5 Flash Image's multi-image composition capability
   * - Constructs enhanced prompts for context-aware character integration
   * - Preserves original scene lighting, background, and composition
   * - Handles style consistency across multiple scene replacements
   */
  async replaceCharacter(
    originalImageData: string,
    characterImageData: string,
    prompt: string,
    options?: {
      targetDescription?: string;
      preserveStyle?: boolean;
      characterDescription?: string;
    }
  ): Promise<NanoBananaResponse> {
    const { targetDescription, preserveStyle = true, characterDescription } = options || {};
    
    /**
     * Enhanced Prompt Construction for Character Replacement
     * 
     * The prompt engineering here is critical for consistent character replacement.
     * We layer multiple instructions to guide Gemini 2.5 Flash Image in producing
     * professional-quality character integration:
     * 
     * 1. Base prompt: User's natural language instruction
     * 2. Target specification: Precise description of what to replace
     * 3. Style preservation: Explicit instructions to maintain scene integrity
     * 4. Character context: Additional details about the replacement character
     */
    let enhancedPrompt = prompt;
    
    // Layer 1: Specify exact replacement target if provided
    if (targetDescription) {
      enhancedPrompt += `. Specifically replace ${targetDescription}.`;
    }
    
    // Layer 2: Style preservation instructions (critical for professional results)
    if (preserveStyle) {
      enhancedPrompt += ` Maintain the original image's style, lighting, composition, background, and overall aesthetic. `;
      enhancedPrompt += `Only replace the specified person/character while keeping everything else exactly the same. `;
      enhancedPrompt += `The replacement should look natural and seamlessly integrated into the original scene.`;
    }
    
    // Layer 3: Character context for better integration
    if (characterDescription) {
      enhancedPrompt += ` The new character is described as: ${characterDescription}.`;
    }
    
    console.log('üë§ [Nano Banana] Character replacement prompt:', enhancedPrompt);
    
    return this.composeImages(enhancedPrompt, [originalImageData, characterImageData]);
  }

  /**
   * Helper method to convert data URL to base64 data only
   */
  private extractBase64FromDataUrl(dataUrl: string): string {
    const base64Index = dataUrl.indexOf(',');
    return base64Index !== -1 ? dataUrl.substring(base64Index + 1) : dataUrl;
  }

  /**
   * Helper method to create data URL from base64 data
   */
  createDataUrl(base64Data: string, mimeType: string = 'image/png'): string {
    return `data:${mimeType};base64,${base64Data}`;
  }
}

// Export singleton instance
export const nanoBanana = new NanaBananaService();
