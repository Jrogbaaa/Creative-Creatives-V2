import { NanoBananaGenerationRequest, NanoBananaResponse } from '@/types';
import { withCache } from './ai-cache';

/**
 * Nano Banana (Gemini 2.5 Flash Image) Service
 * Uses the direct Gemini API for image generation and editing
 * Based on: https://ai.google.dev/gemini-api/docs/image-generation
 */
class NanaBananaService {
  private apiKey: string;
  private model: string = 'gemini-2.5-flash-image-preview';
  private apiUrl: string = 'https://generativelanguage.googleapis.com/v1beta/models';

  constructor() {
    this.apiKey = process.env.GEMINI_API_KEY || '';
    if (!this.apiKey) {
      console.warn('GEMINI_API_KEY not configured. Nano Banana will not work.');
    }
  }

  /**
   * Generate images using text-to-image (Nano Banana)
   */
  async generateImage(request: NanoBananaGenerationRequest): Promise<NanoBananaResponse> {
    return withCache.image(request.prompt, request, async () => {
      try {
        console.log('üçå [Nano Banana] Starting image generation...');
        console.log('üìù Request:', JSON.stringify(request, null, 2));

        if (!this.apiKey) {
          throw new Error('GEMINI_API_KEY is not configured');
        }

      // Prepare the content array
      const contents = [{
        parts: [{
          text: request.prompt
        }]
      }];

      // Add input images if this is an editing request
      if (request.inputImages && request.inputImages.length > 0) {
        request.inputImages.forEach((imageData, index) => {
          contents[0].parts.push({
            inlineData: {
              mimeType: 'image/png', // Assuming PNG, could be dynamic
              data: imageData
            }
          } as any);
        });
      }

      const response = await fetch(
        `${this.apiUrl}/${this.model}:generateContent?key=${this.apiKey}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents
          }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Nano Banana API error: ${response.statusText} - ${JSON.stringify(errorData)}`);
      }

      const data = await response.json();
      console.log('üìû [Nano Banana] Raw response received');

      // Extract images from response
      const images: { id: string; data: string; mimeType: string; }[] = [];
      
      if (data.candidates && data.candidates[0]?.content?.parts) {
        for (const part of data.candidates[0].content.parts) {
          if (part.inlineData) {
            images.push({
              id: `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              data: part.inlineData.data,
              mimeType: part.inlineData.mimeType || 'image/png'
            });
          }
        }
      }

      if (images.length === 0) {
        console.log('‚ö†Ô∏è [Nano Banana] No images found in response. This might be due to:');
        console.log('   - Gemini 2.5 Flash Image not yet available in your region');
        console.log('   - API key lacks image generation permissions');  
        console.log('   - Model response format has changed');
        console.log('   - Using development mode without proper API setup');
        
        // For development/testing, create a placeholder response
        if (process.env.NODE_ENV === 'development') {
          console.log('üß™ [Nano Banana] Creating placeholder for development');
          images.push({
            id: `placeholder_${Date.now()}`,
            data: 'PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzY2NzA4NSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkdlbmVyYXRlZCBJbWFnZSBQbGFjZWhvbGRlcjwvdGV4dD48L3N2Zz4=',
            mimeType: 'image/svg+xml'
          });
        } else {
          throw new Error('No images were generated by Nano Banana - check API configuration');
        }
      }

      console.log(`‚úÖ [Nano Banana] Successfully generated ${images.length} image(s)`);
      
      return {
        success: true,
        images
      };

    } catch (error) {
      console.error('‚ùå [Nano Banana] Generation error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      };
    }
    });
  }

  /**
   * Edit existing images with text prompts (image + text-to-image)
   */
  async editImage(
    prompt: string, 
    inputImages: string[]
  ): Promise<NanoBananaResponse> {
    return this.generateImage({
      prompt,
      editMode: 'image-and-text-to-image',
      inputImages
    });
  }

  /**
   * Compose new images from multiple input images
   */
  async composeImages(
    prompt: string, 
    inputImages: string[]
  ): Promise<NanoBananaResponse> {
    return this.generateImage({
      prompt,
      editMode: 'multi-image-composition',  
      inputImages
    });
  }

  /**
   * Replace characters in images using reference photos
   */
  async replaceCharacter(
    originalImageData: string,
    characterImageData: string,
    prompt: string,
    options?: {
      targetDescription?: string;
      preserveStyle?: boolean;
      characterDescription?: string;
    }
  ): Promise<NanoBananaResponse> {
    const { targetDescription, preserveStyle = true, characterDescription } = options || {};
    
    // Build enhanced prompt for character replacement
    let enhancedPrompt = prompt;
    
    if (targetDescription) {
      enhancedPrompt += `. Specifically replace ${targetDescription}.`;
    }
    
    if (preserveStyle) {
      enhancedPrompt += ` Maintain the original image's style, lighting, composition, background, and overall aesthetic. `;
      enhancedPrompt += `Only replace the specified person/character while keeping everything else exactly the same. `;
      enhancedPrompt += `The replacement should look natural and seamlessly integrated into the original scene.`;
    }
    
    if (characterDescription) {
      enhancedPrompt += ` The new character is described as: ${characterDescription}.`;
    }
    
    console.log('üë§ [Nano Banana] Character replacement prompt:', enhancedPrompt);
    
    return this.composeImages(enhancedPrompt, [originalImageData, characterImageData]);
  }

  /**
   * Helper method to convert data URL to base64 data only
   */
  private extractBase64FromDataUrl(dataUrl: string): string {
    const base64Index = dataUrl.indexOf(',');
    return base64Index !== -1 ? dataUrl.substring(base64Index + 1) : dataUrl;
  }

  /**
   * Helper method to create data URL from base64 data
   */
  createDataUrl(base64Data: string, mimeType: string = 'image/png'): string {
    return `data:${mimeType};base64,${base64Data}`;
  }
}

// Export singleton instance
export const nanoBanana = new NanaBananaService();
